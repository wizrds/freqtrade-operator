apiVersion: freqtrade.io/v1alpha1
kind: Bot
metadata:
  name: example-freqai-bot
  namespace: default
spec:
  # Like typical bots, define the exchange and corresponding config.
  # See [`basic.bot.yaml`] for more details.
  exchange: kucoin
  config:
    max_open_trades: 4
    stake_currency: USDT
    stake_amount: 0.05
    tradable_balance_ratio: 0.99
    fiat_display_currency: USD
    timeframe: 3m
    dry_run: true
    dry_run_wallet: 10000
    cancel_open_orders_on_exit: false
    unfilledtimeout:
      entry: 10
      exit: 10
      exit_timeout_count: 0
      unit: minutes
    entry_pricing:
      price_side: same
      use_order_book: true
      order_book_top: 1
      price_last_balance: 0.0
      check_depth_of_market:
        enabled: false
        bids_to_ask_delta: 1
    exit_pricing:
      price_side: same
      use_order_book: true
      order_book_top: 1
    exchange:
      ccxt_config: {}
      ccxt_async_config: {}
      pair_whitelist:
        - ALGO/USDT
        - ATOM/USDT
        - ETH/USDT
      pair_blacklist:
        - BNB/.*
    pairlists:
      - method: StaticPairList
    freqai:
      purge_old_models: 2
      train_period_days: 15
      backtest_period_days: 15
      live_retrain_hours: 0
      identifier: unique-id
      feature_parameters:
        include_timeframes:
          - 3m
          - 15m
          - 1h
        include_corr_pairlist:
          - BTC/USDT
          - ETH/USDT
        label_period_candles: 20
        include_shifted_candles: 2
        DI_threshold: 0.9
        weight_factor: 0.9
        principal_component_analysis: false
        use_SVM_to_remove_outliers: true
        indicator_periods_candles:
          - 10
          - 20
        plot_feature_importances: 0
      data_split_parameters:
        test_size: 0.33
        random_state: 1
      model_training_parameters: {}
    telegram:
      enabled: false
    initial_state: running
    force_entry_enable: false
    internals:
      process_throttle_secs: 5
  # Allowing the API server to be enabled is optional.
  # If enabled, the bot will expose an API server that can be used to interact with
  # the bot, such as retrieving the current state, or sending commands to the bot.
  # The API server will be exposed on the host and port defined here, as well as the
  # FreqUI dashboard.
  # If the API server is not enabled, the bot will not expose an API server and thus not
  # create a Service for it.
  api:
    enabled: true
    host: 0.0.0.0
    port: 8081
  # Define the necessary secrets either via inlining the value
  # or by using a Kubernetes secret.
  # If using a Kubernetes secret, the secret must be created in the same namespace as the
  # bot, and instead of using the `value` field, you must use the `secretKeyRef` field.
  secrets:
    api:
      username:
        value: someuser
      password:
        value: somepassword
      wsToken:
        value: sometoken
        # Alternatively, you can use a Kubernetes secret:
        # secretKeyRef:
        #   name: example-freqai-bot-wstoken
        #   key: ws_token
  # Since this is a FreqAI bot we need to use the FreqAI tag for the docker image.
  image:
    repository: freqtradeorg/freqtrade
    tag: stable_freqai
  # Since we're using FreqAI, we define the `model` info. If the `model` info is not defined,
  # then the bot will not be able to use FreqAI functionality.
  # If using a custom dockerfile with the model already included, simply setting the `name` field
  # to the name of the model class is sufficient.
  # If using a custom model that is not included in the docker image, you can
  # define the `source` field with the source code inlined in the manifest. Otherwise
  # you can use the `configMapName` field to reference a ConfigMap that contains the source code
  # under the `model.py` key.
  model:
    # The class name of the model MUST be defined here.
    name: MyLightGBMRegressor
    # If a configmap is used, you must reference it via the `configMapName` field instead.
    # configMapName: example-freqai-model-src
    source: |
      import logging
      from typing import Any

      from lightgbm import LGBMRegressor

      from freqtrade.freqai.base_models.BaseRegressionModel import BaseRegressionModel
      from freqtrade.freqai.data_kitchen import FreqaiDataKitchen


      logger = logging.getLogger(__name__)


      class MyLightGBMRegressor(BaseRegressionModel):
          """
          User created prediction model. The class inherits IFreqaiModel, which
          means it has full access to all Frequency AI functionality. Typically,
          users would use this to override the common `fit()`, `train()`, or
          `predict()` methods to add their custom data handling tools or change
          various aspects of the training that cannot be configured via the
          top level config.json file.
          """

          def fit(self, data_dictionary: dict, dk: FreqaiDataKitchen, **kwargs) -> Any:
              """
              User sets up the training and test data to fit their desired model here
              :param data_dictionary: the dictionary holding all data for train, test,
                  labels, weights
              :param dk: The datakitchen object for the current coin/model
              """

              if self.freqai_info.get("data_split_parameters", {}).get("test_size", 0.1) == 0:
                  eval_set = None
                  eval_weights = None
              else:
                  eval_set = [(data_dictionary["test_features"], data_dictionary["test_labels"])]
                  eval_weights = data_dictionary["test_weights"]
              X = data_dictionary["train_features"]
              y = data_dictionary["train_labels"]
              train_weights = data_dictionary["train_weights"]

              init_model = self.get_init_model(dk.pair)

              model = LGBMRegressor(**self.model_training_parameters)

              model.fit(
                  X=X,
                  y=y,
                  eval_set=eval_set,
                  sample_weight=train_weights,
                  eval_sample_weight=[eval_weights],
                  init_model=init_model,
              )

              return model
  # The strategy information is required for the bot to run. If using a custom
  # dockerfile with the strategy already included, simply setting the `name` field
  # to the class name of the strategy is sufficient.
  # If using a custom strategy that is not included in the docker image, you can
  # define the `source` field with the source code inlined in the manifest. Otherwise
  # you can use the `configMapName` field to reference a ConfigMap that contains the source code
  # under the `strategy.py` key.
  strategy:
    # The class name of the strategy MUST be defined here.
    name: FreqaiExampleStrategy
    # If using a ConfigMap, you must define the `configMapName` field instead.
    # configMapName: example-freqai-bot-strategy-src
    source: |
      import logging
      from functools import reduce

      import talib.abstract as ta
      from pandas import DataFrame
      from technical import qtpylib

      from freqtrade.strategy import IStrategy


      logger = logging.getLogger(__name__)


      class FreqaiExampleStrategy(IStrategy):
          """
          Example strategy showing how the user connects their own
          IFreqaiModel to the strategy.

          Warning! This is a showcase of functionality,
          which means that it is designed to show various functions of FreqAI
          and it runs on all computers. We use this showcase to help users
          understand how to build a strategy, and we use it as a benchmark
          to help debug possible problems.

          This means this is *not* meant to be run live in production.
          """

          minimal_roi = {"0": 0.1, "240": -1}

          plot_config = {
              "main_plot": {},
              "subplots": {
                  "&-s_close": {"&-s_close": {"color": "blue"}},
                  "do_predict": {
                      "do_predict": {"color": "brown"},
                  },
              },
          }

          process_only_new_candles = True
          stoploss = -0.05
          use_exit_signal = True
          # this is the maximum period fed to talib (timeframe independent)
          startup_candle_count: int = 40
          can_short = False

          def feature_engineering_expand_all(
              self, dataframe: DataFrame, period: int, metadata: dict, **kwargs
          ) -> DataFrame:
              """
              *Only functional with FreqAI enabled strategies*
              This function will automatically expand the defined features on the config defined
              `indicator_periods_candles`, `include_timeframes`, `include_shifted_candles`, and
              `include_corr_pairs`. In other words, a single feature defined in this function
              will automatically expand to a total of
              `indicator_periods_candles` * `include_timeframes` * `include_shifted_candles` *
              `include_corr_pairs` numbers of features added to the model.

              All features must be prepended with `%` to be recognized by FreqAI internals.

              Access metadata such as the current pair/timeframe with:

              `metadata["pair"]` `metadata["tf"]`

              More details on how these config defined parameters accelerate feature engineering
              in the documentation at:

              https://www.freqtrade.io/en/latest/freqai-parameter-table/#feature-parameters

              https://www.freqtrade.io/en/latest/freqai-feature-engineering/#defining-the-features

              :param dataframe: strategy dataframe which will receive the features
              :param period: period of the indicator - usage example:
              :param metadata: metadata of current pair
              dataframe["%-ema-period"] = ta.EMA(dataframe, timeperiod=period)
              """

              dataframe["%-rsi-period"] = ta.RSI(dataframe, timeperiod=period)
              dataframe["%-mfi-period"] = ta.MFI(dataframe, timeperiod=period)
              dataframe["%-adx-period"] = ta.ADX(dataframe, timeperiod=period)
              dataframe["%-sma-period"] = ta.SMA(dataframe, timeperiod=period)
              dataframe["%-ema-period"] = ta.EMA(dataframe, timeperiod=period)

              bollinger = qtpylib.bollinger_bands(
                  qtpylib.typical_price(dataframe), window=period, stds=2.2
              )
              dataframe["bb_lowerband-period"] = bollinger["lower"]
              dataframe["bb_middleband-period"] = bollinger["mid"]
              dataframe["bb_upperband-period"] = bollinger["upper"]

              dataframe["%-bb_width-period"] = (
                  dataframe["bb_upperband-period"] - dataframe["bb_lowerband-period"]
              ) / dataframe["bb_middleband-period"]
              dataframe["%-close-bb_lower-period"] = dataframe["close"] / dataframe["bb_lowerband-period"]

              dataframe["%-roc-period"] = ta.ROC(dataframe, timeperiod=period)

              dataframe["%-relative_volume-period"] = (
                  dataframe["volume"] / dataframe["volume"].rolling(period).mean()
              )

              return dataframe

          def feature_engineering_expand_basic(
              self, dataframe: DataFrame, metadata: dict, **kwargs
          ) -> DataFrame:
              """
              *Only functional with FreqAI enabled strategies*
              This function will automatically expand the defined features on the config defined
              `include_timeframes`, `include_shifted_candles`, and `include_corr_pairs`.
              In other words, a single feature defined in this function
              will automatically expand to a total of
              `include_timeframes` * `include_shifted_candles` * `include_corr_pairs`
              numbers of features added to the model.

              Features defined here will *not* be automatically duplicated on user defined
              `indicator_periods_candles`

              All features must be prepended with `%` to be recognized by FreqAI internals.

              Access metadata such as the current pair/timeframe with:

              `metadata["pair"]` `metadata["tf"]`

              More details on how these config defined parameters accelerate feature engineering
              in the documentation at:

              https://www.freqtrade.io/en/latest/freqai-parameter-table/#feature-parameters

              https://www.freqtrade.io/en/latest/freqai-feature-engineering/#defining-the-features

              :param dataframe: strategy dataframe which will receive the features
              :param metadata: metadata of current pair
              dataframe["%-pct-change"] = dataframe["close"].pct_change()
              dataframe["%-ema-200"] = ta.EMA(dataframe, timeperiod=200)
              """
              dataframe["%-pct-change"] = dataframe["close"].pct_change()
              dataframe["%-raw_volume"] = dataframe["volume"]
              dataframe["%-raw_price"] = dataframe["close"]
              return dataframe

          def feature_engineering_standard(
              self, dataframe: DataFrame, metadata: dict, **kwargs
          ) -> DataFrame:
              """
              *Only functional with FreqAI enabled strategies*
              This optional function will be called once with the dataframe of the base timeframe.
              This is the final function to be called, which means that the dataframe entering this
              function will contain all the features and columns created by all other
              freqai_feature_engineering_* functions.

              This function is a good place to do custom exotic feature extractions (e.g. tsfresh).
              This function is a good place for any feature that should not be auto-expanded upon
              (e.g. day of the week).

              All features must be prepended with `%` to be recognized by FreqAI internals.

              Access metadata such as the current pair with:

              `metadata["pair"]`

              More details about feature engineering available:

              https://www.freqtrade.io/en/latest/freqai-feature-engineering

              :param dataframe: strategy dataframe which will receive the features
              :param metadata: metadata of current pair
              usage example: dataframe["%-day_of_week"] = (dataframe["date"].dt.dayofweek + 1) / 7
              """
              dataframe["%-day_of_week"] = dataframe["date"].dt.dayofweek
              dataframe["%-hour_of_day"] = dataframe["date"].dt.hour
              return dataframe

          def set_freqai_targets(self, dataframe: DataFrame, metadata: dict, **kwargs) -> DataFrame:
              """
              *Only functional with FreqAI enabled strategies*
              Required function to set the targets for the model.
              All targets must be prepended with `&` to be recognized by the FreqAI internals.

              Access metadata such as the current pair with:

              `metadata["pair"]`

              More details about feature engineering available:

              https://www.freqtrade.io/en/latest/freqai-feature-engineering

              :param dataframe: strategy dataframe which will receive the targets
              :param metadata: metadata of current pair
              usage example: dataframe["&-target"] = dataframe["close"].shift(-1) / dataframe["close"]
              """
              dataframe["&-s_close"] = (
                  dataframe["close"]
                  .shift(-self.freqai_info["feature_parameters"]["label_period_candles"])
                  .rolling(self.freqai_info["feature_parameters"]["label_period_candles"])
                  .mean()
                  / dataframe["close"]
                  - 1
              )

              # Classifiers are typically set up with strings as targets:
              # df['&s-up_or_down'] = np.where( df["close"].shift(-100) >
              #                                 df["close"], 'up', 'down')

              # If user wishes to use multiple targets, they can add more by
              # appending more columns with '&'. User should keep in mind that multi targets
              # requires a multioutput prediction model such as
              # freqai/prediction_models/CatboostRegressorMultiTarget.py,
              # freqtrade trade --freqaimodel CatboostRegressorMultiTarget

              # df["&-s_range"] = (
              #     df["close"]
              #     .shift(-self.freqai_info["feature_parameters"]["label_period_candles"])
              #     .rolling(self.freqai_info["feature_parameters"]["label_period_candles"])
              #     .max()
              #     -
              #     df["close"]
              #     .shift(-self.freqai_info["feature_parameters"]["label_period_candles"])
              #     .rolling(self.freqai_info["feature_parameters"]["label_period_candles"])
              #     .min()
              # )

              return dataframe

          def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
              # All indicators must be populated by feature_engineering_*() functions

              # the model will return all labels created by user in `set_freqai_targets()`
              # (& appended targets), an indication of whether or not the prediction should be accepted,
              # the target mean/std values for each of the labels created by user in
              # `set_freqai_targets()` for each training period.

              dataframe = self.freqai.start(dataframe, metadata, self)

              return dataframe

          def populate_entry_trend(self, df: DataFrame, metadata: dict) -> DataFrame:
              enter_long_conditions = [
                  df["do_predict"] == 1,
                  df["&-s_close"] > 0.01,
              ]

              if enter_long_conditions:
                  df.loc[
                      reduce(lambda x, y: x & y, enter_long_conditions), ["enter_long", "enter_tag"]
                  ] = (1, "long")

              enter_short_conditions = [
                  df["do_predict"] == 1,
                  df["&-s_close"] < -0.01,
              ]

              if enter_short_conditions:
                  df.loc[
                      reduce(lambda x, y: x & y, enter_short_conditions), ["enter_short", "enter_tag"]
                  ] = (1, "short")

              return df

          def populate_exit_trend(self, df: DataFrame, metadata: dict) -> DataFrame:
              exit_long_conditions = [df["do_predict"] == 1, df["&-s_close"] < 0]
              if exit_long_conditions:
                  df.loc[reduce(lambda x, y: x & y, exit_long_conditions), "exit_long"] = 1

              exit_short_conditions = [df["do_predict"] == 1, df["&-s_close"] > 0]
              if exit_short_conditions:
                  df.loc[reduce(lambda x, y: x & y, exit_short_conditions), "exit_short"] = 1

              return df

          def confirm_trade_entry(
              self,
              pair: str,
              order_type: str,
              amount: float,
              rate: float,
              time_in_force: str,
              current_time,
              entry_tag,
              side: str,
              **kwargs,
          ) -> bool:
              df, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
              last_candle = df.iloc[-1].squeeze()

              if side == "long":
                  if rate > (last_candle["close"] * (1 + 0.0025)):
                      return False
              else:
                  if rate < (last_candle["close"] * (1 - 0.0025)):
                      return False

              return True